双索引:283 26 80 27

---------------------------------------------------------------------------------------
传统算法在其他问题中的拓展:215 88 75

---------------------------------------------------------------------------------------
双指针对撞:344 345 167 125 11

---------------------------------------------------------------------------------------
滑动窗口（比较难）:3 209 438 76 

---------------------------------------------------------------------------------------
set map使用:349 350  练习:242 202 290 205 451 

笔记:当我们存储的东西只有键，不计数，不能重复这些特性，我们用set。
我们存储key-value的时候，用map。

set，map 内部实现 平衡二叉树 插入 查找 删除 都是O(logN)。

unorder_set,unorder_map 内部实现是哈希表  插入 删除 查找 都是O(1) 但是会失去数据的有序性。
---------------------------------------------------------------------------------------
查找表：1 15 18 16（不是查找表）

15 18 可以从查找表解决吗？目前是排序后，指针对撞。

454 49 447 149

---------------------------------------------------------------------------------------
滑动窗口+查找表 217 219 220

---------------------------------------------------------------------------------------
链表问题 206 练习 92    83 86 328 2 445

203 82 21  讲解:24  练习:25 147 [148]没做  讲解:237 19 61 143 234

---------------------------------------------------------------------------------------
栈,队列的使用 讲解:20  练习:150 71

递归与栈 讲解:144 练习: 94 145 341 

queue 讲解:102 练习:107 103 199

BFS和图的最短路径 讲解:279 练习:[127 126]没做

优先队列 讲解:347 练习:23

---------------------------------------------------------------------------------------

二叉树与递归 讲解:104 226 练习:111 100 101 222 110

注意递归终止条件: 讲解:112 练习:404[可优化]

复杂的递归逻辑：讲解：257 437 235  练习：113 129 98 450 108 230 236

---------------------------------------------------------------------------------------

递归和回溯：讲解：17  练习：93 131

排列问题：讲解：46 练习：47

组合问题: 讲解：77 练习：39 40 216 78 90 401 

40 和 47 比较一下

关键语句 要仔细理解
先排序
排列问题去重复:
if( i > 0 && nums[i] == nums[i-1] && !used[i-1]) continue;
组合问题去重复:
if( i > start && num[i] == num[i-1]) continue;

二维平面的回溯 讲解:79 200(floodfill算法) 练习：130 417
八皇后 51 52   数独 37

--------------------------------------------------------------------------------------
动态规划：相当灵活

讲解：斐波那契数列

递归问题->重叠子问题，最优子结构 ->记忆化搜索：自顶向下解决问题
		                 ->动态规划：自底向上解决问题

讲解：70 练习：120 64

讲解：343 练习：279 [91] 62 63

讲解: 198 练习：213 337 [309]

0-1背包 讲解：0-1背包 416 练习：322 377 474 139 494

对于多重背包问题 可以转换为0-1背包求解

状态定义：
二维空间：f(i,c) 在[0...i]中选择物品 装填背包容量c 使得价值最大
一维空间：f(j)  容量为j的背包所能容纳的最大价值

0-1背包：状态转移公式
//二维空间 装与不装当前物品 （不装 ，装）
f(i,c) = max( f(i-1,c) , f(i-1,c-w[i]) + v[i] )
//一维空间
f(j) =   max( f(j) , f(j - w[i]) + v[i] ) //从后向前算

完全背包
//二维空间 （不装，装）
f(i,c) = max( f（i-1,c）, f( i , c-w[i]) + v[i] )
//一维空间
f(j) =   max( f(j) , f(j - w[i]) + v[i] ) //从前向后算

最长上升子序列: 讲解:300 例题:376
